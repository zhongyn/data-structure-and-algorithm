----------------------
Problem 4
----------------------

Say MRD(v) is the minimum number of rounds required for the message to be delivered to all nodes, v is the root node.
Then MRD(v) can be solved in recursion.

MRD(v):
	if children(v) == NULL:
		return 0
	let children(v) = {u1, u2,.., uk}, number of children = k
	maxchild = max(MRD(u1), MRD(u2),.., MRD(uk))
	if k > maxchild:
		retun k
	else:
		return maxchild+1

So we just need to fill out the tree with MSR(v) in bottom-up order, starting from the leaves.

Running time: O(n), each node is called only once by its parent.
Space: O(n)


-----------------------
Problem 3
-----------------------

Say LPS(i,j) is the length of the longest palindrome sequence of string S[i,j](i<=j), given string S[1..n].

The algorithm for finding LPS(i,j):
1. Base case: if i == j, LPS(i,j) = 1; if i < j, LPS(i,j) = 0;
2. If S[j] in LPS(i,j), LPS(i,j) = 2 + LPS(k+1,j-1), where k is the index of the first occurence of S[j] and i<=k<j;
   If S[j] not in LPS(i,j), LPS(i,j) = LPS(j,j-1);
   So LPS(i,j) = max(2+LPS(k+1,j-1), LPS(j,j-1)).

LPS(i,j):
	if i == j: return 1
	if i < j: return 0
	k = the index of the first occurence of S[j], i<=k<j
	if k != NULL:
		return max(2+LPS(k+1,j-1), LPS(i,j-1))
	else:
		return LPS(i,j-1)

Using dynamic programming, we can fill out the table LPS(i,j), 1<=i<=n, 1<=j<=n.
Since i<=j, we only need to fill out half the table.

